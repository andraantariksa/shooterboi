#define MAX_STEP 100
#define MIN_HIT_DIST 0.001
#define MAX_DIST 1000.
#define PI 3.14159265359
#define ROT (sin(15.0) * PI)

float dot2(vec2 a) {
    return dot(a, a);
}

vec3 rotZ(vec3 p, float r) {
    return vec3(p.x * cos(r) + p.y * -sin(r), p.x * sin(r) + p.y * cos(r), p.z);
}

vec3 rotY(vec3 p, float r) {
    return vec3(p.x * cos(r) + p.z * sin(r), p.y, p.x * -sin(r) + p.z * cos(r));
}

vec3 rotX(vec3 p, float r) {
    return vec3(p.x, p.y * cos(r) + p.z * -sin(r), p.y * -sin(r) + p.z * cos(r));
}

float SD2Trapezoid( in vec2 p, in float r1, float r2, float he ) {
    vec2 k1 = vec2(r2,he);
    vec2 k2 = vec2(r2-r1,2.0*he);
    p.x = abs(p.x);
    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);
    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

float SDHexPrism( vec3 p, vec2 h ) {
  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);
  p = abs(p);
  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;
  vec2 d = vec2(
       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),
       p.z-h.y );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float OPSmoothUnion( float d1, float d2, float k ) {
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h);
}

float SDCapsule( vec3 p, vec3 a, vec3 b, float r ) {
  vec3 pa = p - a, ba = b - a;
  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
  return length( pa - ba*h ) - r;
}

float SDBox( vec3 p, vec3 b ) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float SDRoundBox( vec3 p, vec3 b, float r ) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float SDParallelogram( in vec2 p, float wi, float he, float sk ) {
    vec2 e = vec2(sk,he);
    p = (p.y<0.0)?-p:p;
    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);
    vec2  d = vec2(dot(w,w), -w.y);
    float s = p.x*e.y - p.y*e.x;
    p = (s<0.0)?-p:p;
    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);
    d = min( d, vec2(dot(v,v), wi*he-abs(s)));
    return sqrt(d.x)*sign(-d.y);
}

float ToPrism(in float d2d, in float v, in float size) {
    vec2 d = vec2(d2d, abs(v) - 0.5 * size);
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float SDParallelogramPrism(vec3 p, in float depth) {
    return ToPrism(SDParallelogram(p.xy, .5, .2, .2), p.z, depth);
}

float SDOctagonPrism(vec3 p, in float depth) {
    float d1 = SD2Trapezoid(p.xy + vec2(0., 0.25), 0.05, 0.1, 0.25);
    float d2 = SD2Trapezoid(p.xy + vec2(0., -0.25), 0.1, 0.05, 0.25);
    return ToPrism(min(d1, d2), p.z, depth);
}

float GunModel(vec3 rayOrigin, vec3 currentPos_) {
    vec3 currentPos = rotY(currentPos_ + vec3(0., 0., 0.), iTime);
    //vec3 currentPos = currentPos_ - rayOrigin + vec3(-1., .5, -4.);
    //currentPos = rotY(currentPos, PI * 1.5);
    float top = SDOctagonPrism(rotY(currentPos, PI / 2.), 4.);
    float handle = SDBox(rotZ(currentPos + vec3(-1.6, 0.9, 0.), 70. * PI / 180.),
                              vec3(0.9, 0.3, 0.08));
    float trigger = SDParallelogramPrism(rotY(currentPos + vec3(-.7, .5, 0.), PI),
                                    0.1);
    float triggerGap = SDCapsule(currentPos,
                                 vec3(1., -.5, 0.),
                                 vec3(.5, -.5, 0.),
                                 0.15);
    float distanceToClosest = min(top, handle);
    distanceToClosest = min(trigger, distanceToClosest);
    distanceToClosest = max(distanceToClosest, -triggerGap);
    return distanceToClosest;
}

float MapToTheWorld(vec3 rayOrigin, vec3 currentPos) {
    float distanceToClosest = GunModel(rayOrigin, currentPos);
    return distanceToClosest;
}

vec3 GetNormal(vec3 rayOrigin, vec3 currentPos) {
    float distanceToAny = MapToTheWorld(rayOrigin, currentPos);
    vec2 epsilon = vec2(MIN_HIT_DIST, 0.);
    vec3 pEpsilon = vec3(MapToTheWorld(rayOrigin, currentPos - epsilon.xyy),
                         MapToTheWorld(rayOrigin, currentPos - epsilon.yxy),
                         MapToTheWorld(rayOrigin, currentPos - epsilon.yyx));
    return normalize(pEpsilon - distanceToAny);
}

vec3 RayMarch(vec3 rayOrigin,
              vec3 rayDistance,
              vec3 lightingPos) {
    float distanceTraveled = 0.;
    for (int i = 0; i < MAX_STEP; ++i) {
        vec3 currentPos = rayOrigin +
            distanceTraveled * rayDistance;
        float distanceToClosest = MapToTheWorld(rayOrigin, currentPos);
        
        if (distanceToClosest < MIN_HIT_DIST) {
            vec3 normal = GetNormal(rayOrigin, currentPos);
            vec3 dirToLight = normalize(
                currentPos - lightingPos);
            float diffuseIntegrity =
                max(0.0,
                    dot(normal, dirToLight));
            
            //return normal * 0.5 + 0.5;
            //return texture(iChannel0, currentPos.xy).xyz;
            return vec3(168., 169., 173.) / 255. * diffuseIntegrity;
        }
        
        if (distanceTraveled > MAX_DIST) {
            break;
        }
        
        distanceTraveled += distanceToClosest;
    }
    
    // Default color
    return vec3(1.);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
	uv -= 0.5;
	uv.x *= iResolution.x / iResolution.y;
    
    vec3 cameraPos = vec3(0., 0., -5.);
    vec3 lightingPos = vec3(0., 0., -5.);
    vec3 rayOrigin = cameraPos;
    vec3 rayDirection = normalize(vec3(uv, 1.));
    
    vec3 color = RayMarch(rayOrigin,
                          rayDirection,
                          lightingPos);
    
    fragColor = vec4(color, 1.0);
}